---
title: Custom Events
description: Learn how to use custom events with the useAppEvent hook
category: Hooks
---

# Custom Events with useAppEvent

This example demonstrates how to extend the `useAppEvent` hook with custom events for your PlayCanvas application.

## Overview

The `useAppEvent` hook supports custom events through TypeScript generics. You can define your own event map without needing to extend anything, providing full type safety for custom application logic.

## Example

```jsx
import React, { useRef, useEffect } from 'react';
import { Application, Entity } from '@playcanvas/react';
import { useAppEvent, BaseEventCallbackMap } from '@playcanvas/react/hooks';
import { Camera } from '@playcanvas/react/components';
import { OrbitControls } from '@playcanvas/react/scripts';

// Define your custom event map - no inheritance needed
interface GameEventMap {
  levelComplete: (level: number, score: number) => void;
  playerDeath: (position: [number, number, number]) => void;
  powerUpCollected: (type: string, duration: number) => void;
}

const GameComponent = () => {
  const appRef = useRef(null);

  // Subscribe to custom events with full type safety
  useAppEvent<GameEventMap>('levelComplete', (level, score) => {
    console.log(`ðŸŽ‰ Level ${level} completed with score ${score}!`);
  });

  useAppEvent<GameEventMap>('playerDeath', (position) => {
    console.log('ðŸ’€ Player died at position:', position);
  });

  useAppEvent<GameEventMap>('powerUpCollected', (type, duration) => {
    console.log(`âš¡ Collected ${type} power-up for ${duration} seconds`);
  });

  // Subscribe to built-in events separately (no generic needed)
  useAppEvent('update', (dt) => {
    // Game loop logic here
  });

  // Fire custom events from your game logic
  useEffect(() => {
    if (!appRef.current) return;

    const app = appRef.current;

    // Simulate some game events
    const gameEvents = [
      { event: 'levelComplete', args: [1, 1500] },
      { event: 'powerUpCollected', args: ['speed', 10] },
      { event: 'playerDeath', args: [[5, 0, 3]] },
    ];

    let eventIndex = 0;
    const interval = setInterval(() => {
      if (eventIndex < gameEvents.length) {
        const { event, args } = gameEvents[eventIndex];
        app.fire(event, ...args);
        eventIndex++;
      } else {
        clearInterval(interval);
      }
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  return (
    <Entity ref={appRef}>
      <Camera fov={30} />
      <OrbitControls />
    </Entity>
  );
};

export default function CustomEventsExample() {
  return (
    <Application>
      <GameComponent />
    </Application>
  );
}
```

## Key Points

1. **Type Safety**: Custom events maintain full TypeScript support with proper callback signatures
2. **Flexibility**: Your event map is completely independent - no need to extend anything
3. **Event Firing**: Use `app.fire('eventName', ...args)` to trigger custom events
4. **Backward Compatibility**: Existing code continues to work unchanged
5. **Clean Separation**: Built-in events and custom events are handled separately

## Use Cases

- **Game Logic**: Level completion, player actions, scoring events
- **UI State**: Menu changes, dialog events, navigation
- **Asset Loading**: Progress updates, completion notifications
- **Physics Events**: Collisions, triggers, state changes
- **User Interactions**: Custom input handling, gesture recognition
