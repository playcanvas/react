{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "SplatViewer",
  "type": "registry:block",
  "title": "Splat Viewer",
  "author": "Mark Lundin",
  "description": "A responsive and composable component for displaying Gaussian splats.",
  "dependencies": [
    "lucide-react",
    "@radix-ui/react-slot",
    "class-variance-authority",
    ".",
    "@radix-ui/react-tooltip"
  ],
  "registryDependencies": [
    "button",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "registry/splat-viewer/download-button.tsx",
      "content": "\"use client\";\n\nimport { DownloadIcon } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useAssetViewer } from \"./splat-viewer-context\";\nimport { TooltipTrigger, TooltipContent, Tooltip } from \"@/components/ui/tooltip\";\n\ntype DownloadButtonProps = {\n  variant?: \"default\" | \"outline\" | \"ghost\" | \"link\";\n}\n\nfunction DownloadButton({ variant = \"ghost\" }: DownloadButtonProps) {\n  const { src } = useAssetViewer(); // assume src is a URL string\n\n  const handleDownload = () => {\n    if (!src) return;\n\n    const link = document.createElement(\"a\");\n    link.href = src;\n    link.download = src.split(\"/\").pop() || \"asset\";\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  };\n\n  return (\n    <Tooltip>\n        <TooltipTrigger asChild>\n            <Button\n                className=\"cursor-pointer pointer-events-auto\"\n                variant={variant} \n                size=\"icon\"\n                onClick={handleDownload}\n                disabled={!src}\n                title=\"Download asset\"\n            >\n                <DownloadIcon />\n            </Button>\n        </TooltipTrigger>\n        <TooltipContent sideOffset={4}>\n            Download\n        </TooltipContent>\n    </Tooltip>\n  );\n}\n\nexport { DownloadButton };",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/full-screen-button.tsx",
      "content": "\"use client\";\n\nimport { MaximizeIcon, MinimizeIcon } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useAssetViewer } from \"./splat-viewer-context\";\nimport { TooltipTrigger, TooltipContent, Tooltip } from \"@/components/ui/tooltip\";\n\nconst FullScreenToggleIcon = ({ isFullscreen }: { isFullscreen: boolean }) => {\n    return isFullscreen ? <MinimizeIcon /> : <MaximizeIcon />;\n}\n\ntype FullScreenButtonProps = {\n    variant?: \"default\" | \"outline\" | \"ghost\" | \"link\";\n}\n\nfunction FullScreenButton({ variant = \"ghost\" }: FullScreenButtonProps) {\n    const { isFullscreen, toggleFullscreen } = useAssetViewer();\n\n    return (<Tooltip>\n        <TooltipTrigger asChild>\n            <Button className=\"cursor-pointer pointer-events-auto\" variant={variant} size=\"icon\" onClick={toggleFullscreen}>\n                <FullScreenToggleIcon isFullscreen={isFullscreen} />\n            </Button>\n        </TooltipTrigger>\n        <TooltipContent sideOffset={4}>\n            {isFullscreen ? \"Exit Fullscreen\" : \"Enter Fullscreen\"}\n        </TooltipContent>\n    </Tooltip>);\n}\n\nexport { FullScreenButton };",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/index.tsx",
      "content": "export * from \"./splat-viewer\";\nexport * from \"./full-screen-button\";\nexport * from \"./download-button\";\nexport * from \"./menu-button\";\n// export * from \"./timeline\";",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/menu-button.tsx",
      "content": "\"use client\";\n\nimport { DropdownMenu, DropdownMenuCheckboxItem, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel, DropdownMenuSeparator, DropdownMenuShortcut, DropdownMenuTrigger } from \"@/components/ui/dropdown-menu\";\nimport { Button } from \"@/components/ui/button\";\nimport { EllipsisVerticalIcon } from \"lucide-react\";\nimport { useState } from \"react\";\n\nfunction MenuButton() {\n\n    const [autoRotate, setAutoRotate] = useState(true);\n\n    return (\n        <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n                <Button className=\"cursor-pointer pointer-events-auto\" variant=\"ghost\" size=\"icon\">\n                    <EllipsisVerticalIcon />\n                </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent side=\"top\" className=\"w-56\">\n                <DropdownMenuLabel>Settings</DropdownMenuLabel>\n                <DropdownMenuSeparator />\n                <DropdownMenuItem>\n                    Fullscreen\n                    <DropdownMenuShortcut>⇧⌘F</DropdownMenuShortcut>\n                </DropdownMenuItem>\n                <DropdownMenuItem>\n                    Download\n                    <DropdownMenuShortcut>⇧⌘D</DropdownMenuShortcut>\n                </DropdownMenuItem>\n                <DropdownMenuCheckboxItem\n                    checked={autoRotate}\n                    onCheckedChange={setAutoRotate}\n                    disabled\n                    >\n                    Auto Rotate\n                    <DropdownMenuShortcut>⇧⌘R</DropdownMenuShortcut>\n                </DropdownMenuCheckboxItem>\n                \n            </DropdownMenuContent>\n        </DropdownMenu>\n    )\n}\n\nexport { MenuButton };",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/splat-viewer.tsx",
      "content": "\"use client\"\n\nimport { Application, Entity } from \"@playcanvas/react\"\nimport { useApp, useParent, useSplat } from \"@playcanvas/react/hooks\"\nimport { Camera, GSplat, Script } from \"@playcanvas/react/components\"\nimport { Suspense, useEffect, useRef, useState } from \"react\"\nimport { CameraControls } from 'playcanvas/scripts/esm/camera-controls.mjs';\nimport { GSplatComponent, Vec3 } from \"playcanvas\"\nimport { AssetViewerProvider } from \"./splat-viewer-context\"\nimport { TooltipProvider } from \"@components/ui/tooltip\"\nimport { cn } from \"@lib/utils\"\nimport { StaticPostEffects } from \"@components/PostEffects\"\nimport { AnimationTrack } from \"./utils/animation\"\nimport { computeStartingPose } from \"./utils/pose\"\n\n// mock anim track\n// import { mockAnimTrack } from \"./utils/mock-anim-track\"\n\ntype CameraControlsProps = {\n    /** \n     * The type of camera controls to use. \n     * \n     * - `animation`: An animation camera that follows the splat.\n     * - `orbit`: An orbit camera that follows the splat.\n     * - `fly`: A fly camera that follows the splat.\n     */\n    type: 'orbit'// | 'animation' |  'fly',\n}\n\ntype SplatViewerComponentProps = CameraControlsProps & {\n    /**\n     * The url of the resource \n     */\n    src: string,\n    /**\n     * The track to use for the animation \n     */\n    track?: AnimationTrack,\n}\n\ntype PosterComponentProps = {\n    /**\n     * The url of the poster image \n     */\n    poster?: string,\n}\n\nexport type SplatViewerProps = SplatViewerComponentProps & PosterComponentProps & {\n    /**\n     * The className of the container \n     */\n    className?: string,\n    /**\n     * The children of the component \n     */\n    children?: React.ReactNode,\n}\n\nfunction SplatComponent({ src }: SplatViewerComponentProps) {\n\n    const { asset, error } = useSplat(src)\n\n    // unload the asset when the component is unmounted\n    useEffect(() => {\n        return () => {\n            asset?.unload();\n        }\n    }, [asset]);\n    \n    if (error) throw new Error(error);\n    if (!asset) return null;\n\n    return (\n        <>\n            { \n                // type === 'animation' ? <AnimationCamera fov={30} track={track} /> : \n                // type === 'orbit' ? <InteractiveCamera fov={30} /> :\n                <InteractiveCamera fov={30} /> \n            }\n            <GSplat asset={asset} />\n        </>\n    )\n}\n\nfunction PosterComponent({ poster }: PosterComponentProps) {\n    return (\n        <img src={poster} alt=\"poster\" />\n    )\n}\n\ntype CameraControlsProps2 = {\n    /* The focus point of the camera */\n    focus?: [number, number, number]\n}\n\nfunction CameraController({ focus = [0, 0, 0] }: CameraControlsProps2) {\n\n    const entity = useParent();\n\n    useEffect(() => {\n        // @ts-expect-error CameraControls is not defined in the script\n        const controls = entity.script?.cameraControls as CameraControls;\n        if (controls) {\n            controls.focus(new Vec3().fromArray(focus));\n        }\n    }, [...focus]);\n\n    return (<>\n        <Script script={CameraControls} rotateSpeed={0.5} rotateDamping={0.985}/*enableFly={type === 'fly'} */ />\n    </>);\n}\n\ntype PoseType = {\n    position: [number, number, number],\n    target: [number, number, number]\n}\n\nconst stylized = {\n    \"lighting\": {\n        \"exposure\": 1.0,\n        \"skyBoxIntensity\": 1.0\n    },\n    \"rendering\": {\n        \"renderFormat\": 18,\n        \"renderTargetScale\": 1,\n        \"sharpness\": 0,\n        \"samples\": 4,\n        \"toneMapping\": 4,\n        \"fog\": \"none\",\n        \"fogColor\": {\n            \"r\": 0,\n            \"g\": 0,\n            \"b\": 0,\n            \"a\": 1\n        },\n        \"fogRange\": [\n            0,\n            100\n        ],\n        \"fogDensity\": 0.01,\n        \"renderFormatFallback0\": 12,\n        \"renderFormatFallback1\": 14,\n        \"sceneColorMap\": false,\n        \"sceneDepthMap\": false,\n        \"fogStart\": 0,\n        \"fogEnd\": 100\n    },\n    \"ssao\": {\n        \"type\": \"none\",\n        \"intensity\": 0.5,\n        \"radius\": 30,\n        \"samples\": 12,\n        \"power\": 6,\n        \"minAngle\": 10,\n        \"scale\": 1,\n        \"blurEnabled\": true\n    },\n    \"bloom\": {\n        \"enabled\": true,\n        \"intensity\": 0.03,\n        \"lastMipLevel\": 1\n    },\n    \"grading\": {\n        \"enabled\": true,\n        \"brightness\": 0.93,\n        \"contrast\": 1.16,\n        \"saturation\": 1.4,\n        \"tint\": {\n            \"r\": 1,\n            \"g\": 0.9333333333333333,\n            \"b\": 0.8666666666666667,\n            \"a\": 1\n        }\n    },\n    \"vignette\": {\n        \"enabled\": true,\n        \"intensity\": 0.4,\n        \"inner\": 0.25,\n        \"outer\": 1.52,\n        \"curvature\": 0.78\n    },\n    \"taa\": {\n        \"enabled\": false,\n        \"jitter\": 0.4\n    },\n    \"fringing\": {\n        \"enabled\": true,\n        \"intensity\": 10\n    }\n}\n\nfunction InteractiveCamera({ fov = 30 }: { fov: number }) {\n\n    const app = useApp();\n    const [pose, setPose] = useState<PoseType>({\n        position: [2, 1, 2],\n        target: [0, 0, 0]\n    });\n\n    useEffect(() => {\n        const gsplat = app.root.findComponent('gsplat') as GSplatComponent;\n        const initialPose = computeStartingPose(gsplat, fov);\n        setPose(initialPose);\n\n    }, [app]);\n\n    if (!pose) return null;\n\n    return (\n        <Entity name='camera' position={pose.position} >\n            <Camera fov={fov} clearColor='#f3e8ff'/>\n            <CameraController focus={pose.target} />\n            <StaticPostEffects {...stylized}/>\n        </Entity>\n    )\n}\n\n// function AnimationCamera({ fov = 30, track }: { fov: number, track: AnimationTrack }) {\n\n//     const entityRef = useRef<PcEntity>(null);\n//     const { subscribe } = useTimeline();\n//     const animation = AnimCamera.fromTrack(track);\n\n//     useEffect(() => {\n//         const pose = new Pose();\n        \n//         const unsubscribe = subscribe((t: number) => {\n//             if (!animation) return;\n//             console.log(t, track.frameRate, track.duration);\n//             animation.cursor.value = t * track.frameRate;\n//             animation.update();\n//             animation.getPose(pose);\n//             const entity = entityRef.current;\n//             entity.setPosition(animation.position);\n//             entity.setRotation(pose.rotation);\n//         });\n\n//         return unsubscribe;\n        \n//     }, [subscribe]);\n\n//     if (!track) {\n//         console.warn('No track provided');\n//         return null;\n//     }\n\n//     return (\n//         <Entity name='camera' ref={entityRef}>\n//             <Camera fov={fov} clearColor='#f3e8ff'/>\n//         </Entity>\n//     )\n// }\n\n/**\n * The SplatViewer is a component that displays a Gaussian Splat.\n */\nexport function SplatViewer( { src, poster, children, className, ...props } : SplatViewerProps) {\n\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    return (\n        <div ref={containerRef} className={cn(\"relative overflow-hidden\", className)}> \n            <AssetViewerProvider targetRef={containerRef} src={src}>\n                <Suspense fallback={<PosterComponent poster={poster} />} >\n                    <Application fillMode=\"NONE\" resolutionMode=\"AUTO\" autoRender={true}>\n                        <SplatComponent src={src} {...props} />\n                    </Application>\n                    <div className=\"absolute w-full h-full top-0 left-0 pointer-events-none flex items-end justify-start p-2 gap-2\">\n                        <TooltipProvider>\n                            {children}\n                        </TooltipProvider>\n                    </div>\n                </Suspense>\n            </AssetViewerProvider>\n        </div>\n    )\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/splat-viewer-context.tsx",
      "content": "import { createContext, useCallback, useEffect, useState, useContext, ReactNode, useRef } from \"react\";\n\ntype AssetViewerContextValue = {\n  isFullscreen: boolean;\n  toggleFullscreen: () => void;\n  src: string;\n};\n\nexport const AssetViewerContext = createContext<AssetViewerContextValue | undefined>(undefined);\n\nexport function useAssetViewer() {\n  const ctx = useContext(AssetViewerContext);\n  if (!ctx) throw new Error(\"useAssetViewer must be used within an AssetViewerProvider\");\n  return ctx;\n}\n\nexport function AssetViewerProvider({\n  children,\n  targetRef,\n  src,\n}: {\n  children: React.ReactNode;\n  targetRef: React.RefObject<HTMLElement>;\n  src: string;\n}) {\n  const [isFullscreen, setIsFullscreen] = useState(false);\n\n  const toggleFullscreen = useCallback(() => {\n    const el = targetRef.current;\n    if (!el) return;\n\n    if (document.fullscreenElement) {\n      document.exitFullscreen();\n    } else {\n      el.requestFullscreen();\n    }\n  }, [targetRef]);\n\n  useEffect(() => {\n    const handler = () => setIsFullscreen(!!document.fullscreenElement);\n    document.addEventListener(\"fullscreenchange\", handler);\n    return () => document.removeEventListener(\"fullscreenchange\", handler);\n  }, []);\n\n  return (\n    <AssetViewerContext.Provider\n      value={{\n        isFullscreen,\n        toggleFullscreen,\n        src,\n      }}\n    >\n      <TimelineProvider>\n          {children}\n      </TimelineProvider>\n    </AssetViewerContext.Provider>\n  );\n}\n  \ntype TimelineContextValue = {\n  getTime: () => number;\n  setTime: (value: number) => void;\n  onCommit?: (value: number) => void;\n  subscribe: (fn: (value: number) => void) => () => void;\n  isPlaying: boolean;\n  setIsPlaying: (value: boolean) => void;\n};\n\nconst TimelineContext = createContext<TimelineContextValue | undefined>(undefined);\n\nexport function useTimeline() {\n  const ctx = useContext(TimelineContext);\n  if (!ctx) throw new Error(\"useTimeline must be used within a TimelineProvider\");\n  return ctx;\n}\n\nexport function TimelineProvider({\n  children,\n}: {\n  children: ReactNode;\n}) {\n  const [time, _setTime] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const timeRef = useRef(time);\n  const rafIdRef = useRef<number | null>(null);\n  const subscribers = useRef(new Set<(v: number) => void>());\n\n  const setTime = useCallback((value: number) => {\n    timeRef.current = value;\n    subscribers.current.forEach((fn) => fn(value));\n  }, []);\n\n  const getTime = useCallback(() => timeRef.current, []);\n\n  const subscribe = useCallback((fn: (v: number) => void) => {\n    subscribers.current.add(fn);\n    return () => subscribers.current.delete(fn);\n  }, []);\n\n  // Example: when time is changed and user commits it\n  const onCommit = useCallback((value: number) => {\n    timeRef.current = value;\n    setTime(value);\n    _setTime(value);\n  }, []);\n\n  const lastTimestampRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    if (isPlaying) {\n      const step = (timestamp: number) => {\n        if (lastTimestampRef.current == null) {\n          lastTimestampRef.current = timestamp;\n        }\n\n        const delta = (timestamp - lastTimestampRef.current) / 1000;\n        lastTimestampRef.current = timestamp;\n\n        setTime(getTime() + delta);\n        rafIdRef.current = requestAnimationFrame(step);\n      };\n\n      lastTimestampRef.current = null;\n      rafIdRef.current = requestAnimationFrame(step);\n    }\n\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current);\n        rafIdRef.current = null;\n      }\n    };\n  }, [isPlaying, getTime, setTime]);\n\n  return (\n    <TimelineContext.Provider\n      value={{ getTime, setTime, onCommit, subscribe, isPlaying, setIsPlaying }}\n    >\n      {children}\n    </TimelineContext.Provider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/splat-viewer/utils/animation.ts",
      "content": "import { Vec3 } from 'playcanvas';\n\nimport { MyQuat } from './math';\nimport { CubicSpline } from './spline';\n\nconst q = new MyQuat();\n\nexport type AnimationTrack = {\n    /* The name of the track */\n    name: string,\n    /* The duration of the track */\n    duration: number,\n    /* The frame rate of the track */\n    frameRate: number,\n    /* The target of the track */\n    target: string,\n    /* The loop mode of the track */\n    loopMode: 'none' | 'repeat' | 'pingpong',\n    /* The interpolation of the track */\n    interpolation: 'spline',\n    /* The keyframes of the track */\n    keyframes: {\n        times: number[],\n        values: {\n            position: number[],\n            target: number[]\n        }\n    }\n}\n\n// track an animation cursor with support for looping and ping-pong modes\nclass AnimCursor {\n    duration = 0;\n\n    loopMode = 'none';\n\n    timer = 0;\n\n    cursor = 0;\n\n    constructor(duration = 0, loopMode = 'none') {\n        this.reset(duration, loopMode);\n    }\n\n    // update(deltaTime) {\n    //     // update animation timer\n    //     this.timer += deltaTime;\n\n    //     // update the track cursor\n    //     this.cursor += deltaTime;\n\n    //     if (this.cursor >= this.duration) {\n    //         switch (this.loopMode) {\n    //             case 'none': this.cursor = this.duration; break;\n    //             case 'repeat': this.cursor %= this.duration; break;\n    //             case 'pingpong': this.cursor %= (this.duration * 2); break;\n    //         }\n    //     }\n    // }\n\n    reset(duration = 0, loopMode = 'none') {\n        this.duration = duration;\n        this.loopMode = loopMode;\n        this.timer = 0;\n        this.cursor = 0;\n    }\n\n    set value(value) {\n        if (value < this.duration) {\n            this.cursor = value;\n        } else {\n            switch (this.loopMode) {\n                case 'none': this.cursor = this.duration; break;\n                case 'repeat': this.cursor %= this.duration; break;\n                case 'pingpong': this.cursor %= (this.duration * 2); break;\n            }\n        }\n    }\n\n    get value() {\n        return this.cursor;// > this.duration ? this.duration - this.cursor : this.cursor;\n    }\n}\n\n// Manage the state of a camera animation track\nclass AnimCamera {\n\n    time = 0;\n    spline;\n\n    cursor: AnimCursor = new AnimCursor();\n\n    frameRate: number;\n\n    result: number[] = [];\n\n    position: Vec3 = new Vec3();\n\n    target = new Vec3();\n\n    rotateSpeed = 0.2;\n\n    rotation = new Vec3();\n\n    constructor(spline, duration, loopMode, frameRate) {\n        this.time = 0\n        this.spline = spline;\n        this.cursor.reset(duration, loopMode);\n        this.frameRate = frameRate;\n\n        // initialize the camera to the start frame\n        this.update();\n    }\n\n    update() {\n        const { cursor, result, spline, frameRate, position, target, rotateSpeed, rotation } = this;\n\n        // update the animation cursor\n        // cursor.update(deltaTime);\n\n        // evaluate the spline\n        spline.evaluate(cursor.value * frameRate, result);\n\n        if (result.every(isFinite)) {\n            position.set(result[0], result[1], result[2]);\n            target.set(result[3], result[4], result[5]);\n        }\n\n        // // rotate\n        // if (input?.rotate) {\n        //     if (input.rotate.events.indexOf('up') !== -1) {\n        //         // reset on up event`\n        //         rotation.set(0, 0, 0);\n        //     } else {\n        //         rotation.x = Math.max(-90, Math.min(90, rotation.x - input.rotate.value[1] * rotateSpeed));\n        //         rotation.y = Math.max(-180, Math.min(180, rotation.y - input.rotate.value[0] * rotateSpeed));\n        //     }\n        // }\n    }\n\n    getPose(pose) {\n        const { position, target, rotation } = this;\n\n        pose.fromLookAt(position, target);\n\n        q.setFromAxisAngle(Vec3.RIGHT, rotation.x);\n        pose.rotation.mul2(pose.rotation, q);\n\n        q.setFromAxisAngle(Vec3.UP, rotation.y);\n        pose.rotation.mul2(q, pose.rotation);\n    }\n\n    // construct an animation from a settings track\n    static fromTrack(track) {\n\n        const { keyframes, duration, frameRate, loopMode } = track;\n        const { times, values } = keyframes;\n        const { position, target } = values;\n\n        // construct the points array containing position and target\n        const points = [];\n        for (let i = 0; i < times.length; i++) {\n            points.push(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            points.push(target[i * 3], target[i * 3 + 1], target[i * 3 + 2]);\n        }\n\n        const extra = (duration === times[times.length - 1] / frameRate) ? 1 : 0;\n\n        const spline = CubicSpline.fromPointsLooping((duration + extra) * frameRate, times, points, -1);\n\n        return new AnimCamera(spline, duration, loopMode, frameRate);\n    }\n    \n}\n\nexport { AnimCamera };",
      "type": "registry:lib"
    },
    {
      "path": "registry/splat-viewer/utils/pose.ts",
      "content": "import { BoundingBox, GSplat, GSplatComponent, Vec3 } from 'playcanvas';\n\nimport { lerp, MyQuat } from './math';\n\nconst v = new Vec3();\n\n// stores a camera pose\nclass Pose {\n\n    position: Vec3 = new Vec3();\n    rotation: MyQuat = new MyQuat();\n    distance: number = 1;\n\n    constructor(other = null) {\n        if (other) {\n            this.copy(other);\n        }\n    }\n\n    copy(pose) {\n        this.position.copy(pose.position);\n        this.rotation.copy(pose.rotation);\n        this.distance = pose.distance;\n        return this;\n    }\n\n    lerp(a: Pose, b: Pose, t: number) {\n        this.position.lerp(a.position, b.position, t);\n        this.rotation.lerp(a.rotation, b.rotation, t);\n        this.distance = lerp(a.distance, b.distance, t);\n        return this;\n    }\n\n    fromLookAt(position: Vec3, target: Vec3) {\n        this.position.copy(position);\n        this.rotation.fromLookAt(position, target);\n        this.distance = position.distance(target);\n        return this;\n    }\n\n    calcTarget(target: Vec3) {\n        this.rotation.transformVector(Vec3.FORWARD, v);\n        target.copy(v).mulScalar(this.distance).add(this.position);\n    }\n}\n\nexport type PoseType = {\n    position: [number, number, number],\n    target: [number, number, number]\n}\n\nconst computeStartingPose = (gsplat: GSplatComponent, fov: number) : PoseType => {\n    const bbox = gsplat?.instance?.meshInstance?.aabb ?? new BoundingBox();\n    const sceneSize = bbox.halfExtents.length();\n    const distance = sceneSize / Math.sin(fov / 180 * Math.PI * 0.5);\n\n    const position = new Vec3(2, 1, 2).normalize().mulScalar(distance).add(bbox.center).toArray();\n    const target = bbox.center.toArray();\n\n    return {\n        position,\n        target\n    } as PoseType;\n}\n\nexport { Pose, computeStartingPose };\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/splat-viewer/utils/math.ts",
      "content": "import { Quat, Vec3 } from 'playcanvas';\n\nconst lerp = (a, b, t) => a * (1 - t) + b * t;\n\nconst damp = (damping, dt) => 1 - Math.pow(damping, dt * 1000);\n\n// modulo including negative numbers\nconst mod = (n, m) => ((n % m) + m) % m;\n\nconst x = new Vec3();\nconst y = new Vec3();\nconst z = new Vec3();\n\nclass MyQuat extends Quat {\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;\n    }\n\n    lerp(a, b, t) {\n        const omt = (1 - t) * (a.dot(b) < 0 ? -1 : 1);\n        this.x = a.x * omt + b.x * t;\n        this.y = a.y * omt + b.y * t;\n        this.z = a.z * omt + b.z * t;\n        this.w = a.w * omt + b.w * t;\n        return this.normalize();\n    }\n\n    // set a quaternion given an orthonormal basis\n    fromBasis(x, y, z) {\n        const m00 = x.x;\n        const m01 = x.y;\n        const m02 = x.z;\n        const m10 = y.x;\n        const m11 = y.y;\n        const m12 = y.z;\n        const m20 = z.x;\n        const m21 = z.y;\n        const m22 = z.z;\n\n        if (m22 < 0) {\n            if (m00 > m11) {\n                this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);\n            } else {\n                this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);\n            }\n        } else {\n            if (m00 < -m11) {\n                this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);\n            } else {\n                this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);\n            }\n        }\n\n        this.mulScalar(1.0 / this.length());\n\n        return this;\n    }\n\n    // set this quaternion to the rotation defined by a viewer\n    // placed at position looking at target\n    fromLookAt(position, target) {\n        z.sub2(position, target).normalize();\n        if (Math.abs(z.dot(Vec3.UP)) > 0.9999) {\n            x.cross(Vec3.RIGHT, z).normalize();\n        } else {\n            x.cross(Vec3.UP, z).normalize();\n        }\n        y.cross(z, x);\n        return this.fromBasis(x, y, z);\n    }\n\n    fromArray(array, offset = 0) {\n        this.x = array[offset];\n        this.y = array[offset + 1];\n        this.z = array[offset + 2];\n        return this;\n    }\n\n    toArray(array, offset = 0) {\n        array[offset] = this.x;\n        array[offset + 1] = this.y;\n        array[offset + 2] = this.z;\n        return array;\n    }\n}\n\nclass SmoothDamp {\n    constructor(value, smoothTime = 0.05) {\n        this.dims = value.length;\n        this.value = value;\n        this.target = value.slice();\n        this.velocity = value.slice().fill(0);\n        this.smoothTime = smoothTime;\n    }\n\n    reset(newValue) {\n        const { dims, value, velocity } = this;\n        for (let i = 0; i < dims; i++) {\n            value[i] = newValue[i];\n            velocity[i] = 0;\n        }\n    }\n\n    update(dt) {\n        const { dims, value, target, velocity, smoothTime } = this;\n\n        const omega = 2 / smoothTime;\n        const x = omega * dt;\n        const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);\n\n        for (let i = 0; i < dims; i++) {\n            const change = value[i] - target[i];\n            const temp = (velocity[i] + omega * change) * dt;\n            velocity[i] = (velocity[i] - omega * temp) * exp;\n            value[i] = target[i] + (change + temp) * exp;\n        }\n    }\n}\n\nexport { lerp, damp, mod, MyQuat, SmoothDamp };\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/splat-viewer/utils/spline.ts",
      "content": "class CubicSpline {\n    // control times\n    times;\n\n    // control data: in-tangent, point, out-tangent\n    knots;\n\n    // dimension of the knot points\n    dim;\n\n    constructor(times, knots) {\n        this.times = times;\n        this.knots = knots;\n        this.dim = knots.length / times.length / 3;\n    }\n\n    evaluate(time, result) {\n        const { times } = this;\n        const last = times.length - 1;\n\n        if (time <= times[0]) {\n            this.getKnot(0, result);\n        } else if (time >= times[last]) {\n            this.getKnot(last, result);\n        } else {\n            let seg = 0;\n            while (time >= times[seg + 1]) {\n                seg++;\n            }\n            return this.evaluateSegment(seg, (time - times[seg]) / (times[seg + 1] - times[seg]), result);\n        }\n    }\n\n    getKnot(index, result) {\n        const { knots, dim } = this;\n        const idx = index * 3 * dim;\n        for (let i = 0; i < dim; ++i) {\n            result[i] = knots[idx + i * 3 + 1];\n        }\n    }\n\n    // evaluate the spline segment at the given normalized time t\n    evaluateSegment(segment, t, result) {\n        const { knots, dim } = this;\n\n        const t2 = t * t;\n        const twot = t + t;\n        const omt = 1 - t;\n        const omt2 = omt * omt;\n\n        let idx = segment * dim * 3;\n        for (let i = 0; i < dim; ++i) {\n            const p0 = knots[idx + 1];\n            const m0 = knots[idx + 2];\n            const m1 = knots[idx + dim * 3];\n            const p1 = knots[idx + dim * 3 + 1];\n            idx += 3;\n\n            result[i] =\n                p0 * ((1 + twot) * omt2) +\n                m0 * (t * omt2) +\n                p1 * (t2 * (3 - twot)) +\n                m1 * (t2 * (t - 1));\n        }\n    }\n\n    // create cubic spline data from a set of control points to be interpolated\n    // times: time values for each control point\n    // points: control point values to be interpolated (n dimensional)\n    // tension: level of smoothness, 0 = smooth, 1 = linear interpolation\n    static fromPoints(times, points, tension = 0) {\n        const dim = points.length / times.length;\n        const knots = new Array(times.length * dim * 3);\n\n        for (let i = 0; i < times.length; i++) {\n            const t = times[i];\n\n            for (let j = 0; j < dim; j++) {\n                const idx = i * dim + j;\n                const p = points[idx];\n\n                let tangent;\n                if (i === 0) {\n                    tangent = (points[idx + dim] - p) / (times[i + 1] - t);\n                } else if (i === times.length - 1) {\n                    tangent = (p - points[idx - dim]) / (t - times[i - 1]);\n                } else {\n                    // finite difference tangents\n                    tangent = 0.5 * ((points[idx + dim] - p) / (times[i + 1] - t) + (p - points[idx - dim]) / (t - times[i - 1]));\n\n                    // cardinal spline tangents\n                    // tangent = (points[idx + dim] - points[idx - dim]) / (times[i + 1] - times[i - 1]);\n                }\n\n                // apply tension\n                tangent *= (1.0 - tension);\n\n                knots[idx * 3] = tangent;\n                knots[idx * 3 + 1] = p;\n                knots[idx * 3 + 2] = tangent;\n            }\n        }\n\n        return new CubicSpline(times, knots);\n    }\n\n    // create a looping spline by duplicating animation points at the end and beginning\n    static fromPointsLooping(length, times, points, tension) {\n        if (times.length < 2) {\n            return CubicSpline.fromPoints(times, points, tension);\n        }\n\n        const dim = points.length / times.length;\n        const newTimes = times.slice();\n        const newPoints = points.slice();\n\n        // append first two points\n        newTimes.push(length + times[0], length + times[1]);\n        newPoints.push(...points.slice(0, dim * 2));\n\n        // prepend last two points\n        newTimes.splice(0, 0, times[times.length - 2] - length, times[times.length - 1] - length);\n        newPoints.splice(0, 0, ...points.slice(points.length - dim * 2));\n\n        return CubicSpline.fromPoints(newTimes, newPoints, tension);\n    }\n}\n\nexport { CubicSpline };\n",
      "type": "registry:lib"
    },
    {
      "path": "components/ui/button.tsx",
      "content": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow-xs hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\n        outline:\n          \"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80\",\n        ghost:\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2 has-[>svg]:px-3\",\n        sm: \"h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5\",\n        lg: \"h-10 rounded-md px-6 has-[>svg]:px-4\",\n        icon: \"size-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "components/ui/tooltip.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction TooltipProvider({\n  delayDuration = 0,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {\n  return (\n    <TooltipPrimitive.Provider\n      data-slot=\"tooltip-provider\"\n      delayDuration={delayDuration}\n      {...props}\n    />\n  )\n}\n\nfunction Tooltip({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Root>) {\n  return (\n    <TooltipProvider>\n      <TooltipPrimitive.Root data-slot=\"tooltip\" {...props} />\n    </TooltipProvider>\n  )\n}\n\nfunction TooltipTrigger({\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {\n  return <TooltipPrimitive.Trigger data-slot=\"tooltip-trigger\" {...props} />\n}\n\nfunction TooltipContent({\n  className,\n  sideOffset = 0,\n  children,\n  ...props\n}: React.ComponentProps<typeof TooltipPrimitive.Content>) {\n  return (\n    <TooltipPrimitive.Portal>\n      <TooltipPrimitive.Content\n        data-slot=\"tooltip-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          \"bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </TooltipPrimitive.Content>\n    </TooltipPrimitive.Portal>\n  )\n}\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}