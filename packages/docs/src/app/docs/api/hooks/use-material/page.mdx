---
title: useMaterial
---

## `useMaterial`

The `useMaterial` hook returns a [`StandardMaterial`](https://api.playcanvas.com/classes/Engine.StandardMaterial.html) instance. This is useful if you need to create materials and apply them to `Render` components.
```jsx
import { useMaterial } from '@playcanvas/react/hooks'

/**
 * Create a red glowing box with a grain texture
 */
const RedGlowingBox = () => {

  // load a texture
  const { asset: grainTexture } = useTexture('./grain.jpg');

  // create a material with the texture
  const material = useMaterial({
    diffuse: 'red',
    emissive: 'red',
    emissiveIntensity: 10,
    diffuseMap: grainTexture,
  });

  // return a box with the material
  return <Entity>
    <Render type="box" material={material} /> 
  </Entity>
};
```

## Props

The `StandardMaterial` accepts a many different props which can be found [here](https://api.playcanvas.com/classes/Engine.StandardMaterial.html).

{/* The following is the type definition for the StandardMaterial class. It's statically copied from the PlayCanvas engine. */}
<TSDoc
  code={`
  import { Material, Color } from 'playcanvas';
  type StandardMaterial {
    set alphaFade(arg: boolean);
    get alphaFade(): boolean;

    /** The ambient color of the material. This color value is 3-component (RGB), where each component is between 0 and 1. */
    set ambient(arg: Color);
    get ambient(): Color;

    /** Defines amount of anisotropy. Requires {@link StandardMaterial#enableGGXSpecular} is set to true. - When anisotropy == 0, specular is isotropic. - When anisotropy < 0, anisotropy direction aligns with the tangent, and specular anisotropy increases as the anisotropy value decreases to minimum of -1. - When anisotropy > 0, anisotropy direction aligns with the bi-normal, and specular anisotropy increases as anisotropy value increases to maximum of 1.  */
    set anisotropy(arg: number);
    get anisotropy(): number;

    /** Ambient occlusion intensity. Defaults to 1. */
    set aoIntensity(arg: number);
    get aoIntensity(): number;

    /** seMap The main (primary) diffuse map of the material (default is null). */
    set aoMap(arg: Texture|null);
    get aoMap(): Texture|null;

    /** Color channel of the main (primary) AO map to use. Can be "r", "g", "b" or "a". */
    set aoMapChannel(arg: string);
    get aoMapChannel(): string;

    /** Controls the 2D offset of the main (primary) AO map. Each component is between 0 and 1. */
    set aoMapOffset(arg: Vec2);
    get aoMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the main (primary) AO map. */
    set aoMapRotation(arg: number);
    get aoMapRotation(): number;

    /** Controls the 2D tiling of the main (primary) AO map. */
    set aoMapTiling(arg: Vec2);
    get aoMapTiling(): Vec2;

    /** Main (primary) AO map UV channel */
    set aoMapUv(arg: number);
    get aoMapUv(): number;

    /** The main (primary) diffuse map of the material (default is null). */
    set aoDetailMap(arg: Texture|null);
    get aoDetailMap(): Texture|null;

    /** Color channels of the detail (secondary) AO map to use. Can be "r", "g", "b" or "a" (default is "g"). */
    set aoDetailMapChannel(arg: string);
    get aoDetailMapChannel(): string;

    /** Controls the 2D offset of the detail (secondary) AO map. Each component is between 0 and 1. */
    set aoDetailMapOffset(arg: Vec2);
    get aoDetailMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the detail (secondary) AO map. */
    set aoDetailMapRotation(arg: number);
    get aoDetailMapRotation(): number;

    /** Controls the 2D tiling of the detail (secondary) AO map. */
    set aoDetailMapTiling(arg: Vec2);
    get aoDetailMapTiling(): Vec2;

    /** Detail (secondary) AO map UV channel. */
    set aoDetailMapUv(arg: number);
    get aoDetailMapUv(): number;

    /** Determines how the main (primary) and detail (secondary) AO maps are blended together. Can be: - {@link DETAILMODE_MUL}: Multiply together the primary and secondary colors. - {@link DETAILMODE_ADD}: Add together the primary and secondary colors. - {@link DETAILMODE_SCREEN}: Softer version of {@link DETAILMODE_ADD}. - {@link DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color. - {@link DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker, component-wise. - {@link DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter, component-wise. Defaults to {@link DETAILMODE_MUL}. */
    set aoDetailMode(arg: string);
    get aoDetailMode(): string;

    /** Use mesh vertex colors for AO. If aoMap is set, it'll be multiplied by vertex colors. */
    set aoVertexColor(arg: boolean);
    get aoVertexColor(): boolean;

    /** Vertex color channels to use for AO. Can be "r", "g", "b" or "a". */
    set aoVertexColorChannel(arg: string);
    get aoVertexColorChannel(): string;

    /** The bumpiness of the material. This value scales the assigned main (primary) normal map. It should be normally between 0 (no bump mapping) and 1 (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect. */
    set bumpiness(arg: number);
    get bumpiness(): number;

    /** Defines intensity of clearcoat layer from 0 to 1. Clearcoat layer is disabled when clearCoat == 0. Default value is 0 (disabled). */
    set clearCoat(arg: number);
    get clearCoat(): number;

    /** The bumpiness of the clearcoat layer. This value scales the assigned main clearcoat normal map. It should be normally between 0 (no bump mapping) and 1 (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect. */
    set clearCoatBumpiness(arg: number);
    get clearCoatBumpiness(): number;

    /** Invert the clearcoat gloss component (default is false). Enabling this flag results in material treating the clear coat gloss members as roughness. */
    set clearCoatGlossInvert(arg: boolean);
    get clearCoatGlossInvert(): boolean;

    /** in (primary) diffuse map of the material (default is null). */
    set clearCoatGlossMap(arg: Texture|null);
    get clearCoatGlossMap(): Texture|null;

    /** Color channel of the clearcoat gloss map to use. Can be "r", "g", "b" or "a". */
    set clearCoatGlossMapChannel(arg: string);
    get clearCoatGlossMapChannel(): string;

    /** Controls the 2D offset of the clearcoat gloss map. Each component is between 0 and 1. */
    set clearCoatGlossMapOffset(arg: Vec2);
    get clearCoatGlossMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the clear coat gloss map. */
    set clearCoatGlossMapRotation(arg: number);
    get clearCoatGlossMapRotation(): number;

    /** Controls the 2D tiling of the clearcoat gloss map. */
    set clearCoatGlossMapTiling(arg: Vec2);
    get clearCoatGlossMapTiling(): Vec2;

    /** Clearcoat gloss map UV channel. */
    set clearCoatGlossMapUv(arg: number);
    get clearCoatGlossMapUv(): number;

    /** Use mesh vertex colors for clearcoat glossiness. If clearCoatGlossMap is set, it'll be multiplied by vertex colors. */
    set clearCoatGlossVertexColor(arg: boolean);
    get clearCoatGlossVertexColor(): boolean;

    /** Vertex color channel to use for clearcoat glossiness. Can be "r", "g", "b" or "a". */
    set clearCoatGlossVertexColorChannel(arg: string);
    get clearCoatGlossVertexColorChannel(): string;

    /** Defines the clearcoat glossiness of the clearcoat layer from 0 (rough) to 1 (mirror). */
    set clearCoatGloss(arg: number);
    get clearCoatGloss(): number;

    /** he main (primary) diffuse map of the material (default is null). */
    set clearCoatMap(arg: Texture|null);
    get clearCoatMap(): Texture|null;

    /** Color channel of the clearcoat intensity map to use. Can be "r", "g", "b" or "a". */
    set clearCoatMapChannel(arg: string);
    get clearCoatMapChannel(): string;

    /** Controls the 2D offset of the clearcoat intensity map. Each component is between 0 and 1. */
    set clearCoatMapOffset(arg: Vec2);
    get clearCoatMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the clearcoat intensity map. */
    set clearCoatMapRotation(arg: number);
    get clearCoatMapRotation(): number;

    /** Controls the 2D tiling of the clearcoat intensity map. */
    set clearCoatMapTiling(arg: Vec2);
    get clearCoatMapTiling(): Vec2;

    /** Clearcoat intensity map UV channel. */
    set clearCoatMapUv(arg: number);
    get clearCoatMapUv(): number;

    /** n (primary) diffuse map of the material (default is null). */
    set clearCoatNormalMap(arg: Texture|null);
    get clearCoatNormalMap(): Texture|null;

    /** Controls the 2D offset of the main clearcoat normal map. Each component is between 0 and 1. */
    set clearCoatNormalMapOffset(arg: Vec2);
    get clearCoatNormalMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the main clearcoat map. */
    set clearCoatNormalMapRotation(arg: number);
    get clearCoatNormalMapRotation(): number;

    /** Controls the 2D tiling of the main clearcoat normal map. */
    set clearCoatNormalMapTiling(arg: Vec2);
    get clearCoatNormalMapTiling(): Vec2;

    /** Clearcoat normal map UV channel. */
    set clearCoatNormalMapUv(arg: number);
    get clearCoatNormalMapUv(): number;

    /** Use mesh vertex colors for clearcoat intensity. If clearCoatMap is set, it'll be multiplied by vertex colors. */
    set clearCoatVertexColor(arg: boolean);
    get clearCoatVertexColor(): boolean;

    /** Vertex color channel to use for clearcoat intensity. Can be "r", "g", "b" or "a". */
    set clearCoatVertexColorChannel(arg: string);
    get clearCoatVertexColorChannel(): string;

    /** Map The main (primary) diffuse map of the material (default is null). */
    set cubeMap(arg: Texture|null);
    get cubeMap(): Texture|null;

    /** The type of projection applied to the cubeMap property: - {@link CUBEPROJ_NONE}: The cube map is treated as if it is infinitely far away. - {@link CUBEPROJ_BOX}: Box-projection based on a world space axis-aligned bounding box. Defaults to {@link CUBEPROJ_NONE}. */
    set cubeMapProjection(arg: number);
    get cubeMapProjection(): number;

    /** The world space axis-aligned bounding box defining the box-projection used for the cubeMap property. Only used when cubeMapProjection is set to {@link CUBEPROJ_BOX}. */
    set cubeMapProjectionBox(arg: BoundingBox);
    get cubeMapProjectionBox(): BoundingBox;

    /** The diffuse color of the material. This color value is 3-component (RGB), where each component is between 0 and 1. Defines basic surface color (aka albedo). */
    set diffuse(arg: Color);
    get diffuse(): Color;

    /** ain (primary) diffuse map of the material (default is null). */
    set diffuseDetailMap(arg: Texture|null);
    get diffuseDetailMap(): Texture|null;

    /** Color channels of the detail (secondary) diffuse map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set diffuseDetailMapChannel(arg: string);
    get diffuseDetailMapChannel(): string;

    /** Controls the 2D offset of the detail (secondary) diffuse map. Each component is between 0 and 1. */
    set diffuseDetailMapOffset(arg: Vec2);
    get diffuseDetailMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the main (secondary) diffuse map. */
    set diffuseDetailMapRotation(arg: number);
    get diffuseDetailMapRotation(): number;

    /** Controls the 2D tiling of the detail (secondary) diffuse map. */
    set diffuseDetailMapTiling(arg: Vec2);
    get diffuseDetailMapTiling(): Vec2;

    /** Detail (secondary) diffuse map UV channel. */
    set diffuseDetailMapUv(arg: number);
    get diffuseDetailMapUv(): number;

    /** Determines how the main (primary) and detail (secondary) diffuse maps are blended together. Can be: - {@link DETAILMODE_MUL}: Multiply together the primary and secondary colors. - {@link DETAILMODE_ADD}: Add together the primary and secondary colors. - {@link DETAILMODE_SCREEN}: Softer version of {@link DETAILMODE_ADD}. - {@link DETAILMODE_OVERLAY}: Multiplies or screens the colors, depending on the primary color. - {@link DETAILMODE_MIN}: Select whichever of the primary and secondary colors is darker, component-wise. - {@link DETAILMODE_MAX}: Select whichever of the primary and secondary colors is lighter, component-wise. Defaults to {@link DETAILMODE_MUL}. */
    set diffuseDetailMode(arg: string);
    get diffuseDetailMode(): string;

    /** The main (primary) diffuse map of the material (default is null). */
    set diffuseMap(arg: Texture|null);
    get diffuseMap(): Texture|null;

    /** Color channels of the main (primary) diffuse map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set diffuseMapChannel(arg: string);
    get diffuseMapChannel(): string;

    /** Controls the 2D offset of the main (primary) diffuse map. Each component is between 0 and 1. */
    set diffuseMapOffset(arg: Vec2);
    get diffuseMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the main (primary) diffuse map. */
    set diffuseMapRotation(arg: number);
    get diffuseMapRotation(): number;

    /** Controls the 2D tiling of the main (primary) diffuse map. */
    set diffuseMapTiling(arg: Vec2);
    get diffuseMapTiling(): Vec2;

    /** Main (primary) diffuse map UV channel. */
    set diffuseMapUv(arg: number);
    get diffuseMapUv(): number;

    /** Multiply diffuse by the mesh vertex colors. */
    set diffuseVertexColor(arg: boolean);
    get diffuseVertexColor(): boolean;

    /** Vertex color channels to use for diffuse. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set diffuseVertexColorChannel(arg: string);
    get diffuseVertexColorChannel(): string;

    /** The emissive color of the material. This color value is 3-component (RGB), where each component is between 0 and 1. */
    set emissive(arg: Color);
    get emissive(): Color;

    /** Emissive color multiplier. */
    set emissiveIntensity(arg: number);
    get emissiveIntensity(): number;

    /** The main (primary) diffuse map of the material (default is null). */
    set emissiveMap(arg: Texture|null);
    get emissiveMap(): Texture|null;

    /** Color channels of the emissive map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set emissiveMapChannel(arg: string);
    get emissiveMapChannel(): string;

    /** Controls the 2D offset of the emissive map. Each component is between 0 and 1. */
    set emissiveMapOffset(arg: Vec2);
    get emissiveMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the emissive map. */
    set emissiveMapRotation(arg: number);
    get emissiveMapRotation(): number;

    /** Controls the 2D tiling of the emissive map. */
    set emissiveMapTiling(arg: Vec2);
    get emissiveMapTiling(): Vec2;

    /** Emissive map UV channel. */
    set emissiveMapUv(arg: number);
    get emissiveMapUv(): number;

    /** Use mesh vertex colors for emission. If emissiveMap or emissive are set, they'll be multiplied by vertex colors. */
    set emissiveVertexColor(arg: boolean);
    get emissiveVertexColor(): boolean;

    /** Vertex color channels to use for emission. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set emissiveVertexColorChannel(arg: string);
    get emissiveVertexColorChannel(): string;

    /** Enables GGX specular. Also enables {@link StandardMaterial#anisotropy} parameter to set material anisotropy. */
    set enableGGXSpecular(arg: boolean);
    get enableGGXSpecular(): boolean;

    /** ap The main (primary) diffuse map of the material (default is null). */
    set envAtlas(arg: Texture|null);
    get envAtlas(): Texture|null;

    /** Defines the formula used for Fresnel effect. As a side-effect, enabling any Fresnel model changes the way diffuse and reflection components are combined. When Fresnel is off, legacy non energy-conserving combining is used. When it is on, combining behavior is energy-conserving. - {@link FRESNEL_NONE}: No Fresnel. - {@link FRESNEL_SCHLICK}: Schlick's approximation of Fresnel (recommended). Parameterized by specular color.  */
    set fresnelModel(arg: number);
    get fresnelModel(): number;

    /** Defines the glossiness of the material from 0 (rough) to 1 (shiny). */
    set gloss(arg: number);
    get gloss(): number;

    /** Invert the gloss component (default is false). Enabling this flag results in material treating the gloss members as roughness. */
    set glossInvert(arg: boolean);
    get glossInvert(): boolean;

    /** ap The main (primary) diffuse map of the material (default is null). */
    set glossMap(arg: Texture|null);
    get glossMap(): Texture|null;

    /** Color channel of the gloss map to use. Can be "r", "g", "b" or "a". */
    set glossMapChannel(arg: string);
    get glossMapChannel(): string;

    /** Controls the 2D offset of the gloss map. Each component is between 0 and 1. */
    set glossMapOffset(arg: Vec2);
    get glossMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the gloss map. */
    set glossMapRotation(arg: number);
    get glossMapRotation(): number;

    /** Controls the 2D tiling of the gloss map. */
    set glossMapTiling(arg: Vec2);
    get glossMapTiling(): Vec2;

    /** Gloss map UV channel. */
    set glossMapUv(arg: number);
    get glossMapUv(): number;

    /** Use mesh vertex colors for glossiness. If glossMap is set, it'll be multiplied by vertex colors. */
    set glossVertexColor(arg: boolean);
    get glossVertexColor(): boolean;

    /** Vertex color channel to use for glossiness. Can be "r", "g", "b" or "a". */
    set glossVertexColorChannel(arg: string);
    get glossVertexColorChannel(): string;

    /** p The main (primary) diffuse map of the material (default is null). */
    set heightMap(arg: Texture|null);
    get heightMap(): Texture|null;

    /** Color channel of the height map to use. Can be "r", "g", "b" or "a". */
    set heightMapChannel(arg: string);
    get heightMapChannel(): string;

    /** Height map multiplier. Affects the strength of the parallax effect. */
    set heightMapFactor(arg: number);
    get heightMapFactor(): number;

    /** Controls the 2D offset of the height map. Each component is between 0 and 1. */
    set heightMapOffset(arg: Vec2);
    get heightMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the height map. */
    set heightMapRotation(arg: number);
    get heightMapRotation(): number;

    /** Controls the 2D tiling of the height map. */
    set heightMapTiling(arg: Vec2);
    get heightMapTiling(): Vec2;

    /** Height map UV channel. */
    set heightMapUv(arg: number);
    get heightMapUv(): number;

    /** ap The main (primary) diffuse map of the material (default is null). */
    set lightMap(arg: Texture|null);
    get lightMap(): Texture|null;

    /** Color channels of the lightmap to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set lightMapChannel(arg: string);
    get lightMapChannel(): string;

    /** Controls the 2D offset of the lightmap. Each component is between 0 and 1. */
    set lightMapOffset(arg: Vec2);
    get lightMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the lightmap. */
    set lightMapRotation(arg: number);
    get lightMapRotation(): number;

    /** Controls the 2D tiling of the lightmap. */
    set lightMapTiling(arg: Vec2);
    get lightMapTiling(): Vec2;

    /** Lightmap UV channel */
    set lightMapUv(arg: number);
    get lightMapUv(): number;

    /** Use baked vertex lighting. If lightMap is set, it'll be multiplied by vertex colors. */
    set lightVertexColor(arg: boolean);
    get lightVertexColor(): boolean;

    /** Vertex color channels to use for baked lighting. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set lightVertexColorChannel(arg: string);
    get lightVertexColorChannel(): string;

    /** Defines how much the surface is metallic. From 0 (dielectric) to 1 (metal). */
    set metalness(arg: number);
    get metalness(): number;

    /** he main (primary) diffuse map of the material (default is null). */
    set metalnessMap(arg: Texture|null);
    get metalnessMap(): Texture|null;

    /** Color channel of the metalness map to use. Can be "r", "g", "b" or "a". */
    set metalnessMapChannel(arg: string);
    get metalnessMapChannel(): string;

    /** Controls the 2D offset of the metalness map. Each component is between 0 and 1. */
    set metalnessMapOffset(arg: Vec2);
    get metalnessMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the metalness map. */
    set metalnessMapRotation(arg: number);
    get metalnessMapRotation(): number;

    /** Controls the 2D tiling of the metalness map. */
    set metalnessMapTiling(arg: Vec2);
    get metalnessMapTiling(): Vec2;

    /** Metalness map UV channel. */
    set metalnessMapUv(arg: number);
    get metalnessMapUv(): number;

    /** Use mesh vertex colors for metalness. If metalnessMap is set, it'll be multiplied by vertex colors. */
    set metalnessVertexColor(arg: boolean);
    get metalnessVertexColor(): boolean;

    /** Vertex color channel to use for metalness. Can be "r", "g", "b" or "a". */
    set metalnessVertexColorChannel(arg: string);
    get metalnessVertexColorChannel(): string;

    /** main (primary) diffuse map of the material (default is null). */
    set normalDetailMap(arg: Texture|null);
    get normalDetailMap(): Texture|null;

    /** The bumpiness of the material. This value scales the assigned detail (secondary) normal map. It should be normally between 0 (no bump mapping) and 1 (full bump mapping), but can be set to e.g. 2 to give even more pronounced bump effect. */
    set normalDetailMapBumpiness(arg: number);
    get normalDetailMapBumpiness(): number;

    /** Controls the 2D offset of the detail (secondary) normal map. Each component is between 0 and 1. */
    set normalDetailMapOffset(arg: Vec2);
    get normalDetailMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the detail (secondary) normal map. */
    set normalDetailMapRotation(arg: number);
    get normalDetailMapRotation(): number;

    /** Controls the 2D tiling of the detail (secondary) normal map. */
    set normalDetailMapTiling(arg: Vec2);
    get normalDetailMapTiling(): Vec2;

    /** Detail (secondary) normal map UV channel. */
    set normalDetailMapUv(arg: number);
    get normalDetailMapUv(): number;

    /** p The main (primary) diffuse map of the material (default is null). */
    set normalMap(arg: Texture|null);
    get normalMap(): Texture|null;

    /** Controls the 2D offset of the main (primary) normal map. Each component is between 0 and 1. */
    set normalMapOffset(arg: Vec2);
    get normalMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the main (primary) normal map. */
    set normalMapRotation(arg: number);
    get normalMapRotation(): number;

    /** Controls the 2D tiling of the main (primary) normal map. */
    set normalMapTiling(arg: Vec2);
    get normalMapTiling(): Vec2;

    /** Main (primary) normal map UV channel. */
    set normalMapUv(arg: number);
    get normalMapUv(): number;

    
    set occludeDirect(arg: number);
    get occludeDirect(): number;

    /** Uses ambient occlusion to darken specular/reflection. It's a hack, because real specular occlusion is view-dependent. However, it can be better than nothing. - {@link SPECOCC_NONE}: No specular occlusion - {@link SPECOCC_AO}: Use AO directly to occlude specular. - {@link SPECOCC_GLOSSDEPENDENT}: Modify AO based on material glossiness/view angle to occlude specular.  */
    set occludeSpecular(arg: number);
    get occludeSpecular(): number;

    /** Controls visibility of specular occlusion. */
    set occludeSpecularIntensity(arg: number);
    get occludeSpecularIntensity(): number;

    /** The opacity of the material. This value can be between 0 and 1, where 0 is fully transparent and 1 is fully opaque. If you want the material to be semi-transparent you also need to set the {@link Material#blendType} to {@link BLEND_NORMAL}, {@link BLEND_ADDITIVE} or any other mode. Also note that for most semi-transparent objects you want {@link Material#depthWrite} to be false, otherwise they can fully occlude objects behind them. */
    set opacity(arg: number);
    get opacity(): number;

    /** Used to specify whether opacity is dithered, which allows transparency without alpha blending. Can be: - {@link DITHER_NONE}: Opacity dithering is disabled. - {@link DITHER_BAYER8}: Opacity is dithered using a Bayer 8 matrix. - {@link DITHER_BLUENOISE}: Opacity is dithered using a blue noise. - {@link DITHER_IGNNOISE}: Opacity is dithered using an interleaved gradient noise. Defaults to {@link DITHER_NONE}. */
    set opacityDither(arg: string);
    get opacityDither(): string;

    
    set opacityShadowDither(arg: string);
    get opacityShadowDither(): string;

    /** Used to specify whether specular and reflections are faded out using {@link StandardMaterial#opacity}. Default is true. When set to false use {@link Material#alphaFade} to fade out materials. */
    set opacityFadesSpecular(arg: boolean);
    get opacityFadesSpecular(): boolean;

    /** The main (primary) diffuse map of the material (default is null). */
    set opacityMap(arg: Texture|null);
    get opacityMap(): Texture|null;

    /** Color channel of the opacity map to use. Can be "r", "g", "b" or "a". */
    set opacityMapChannel(arg: string);
    get opacityMapChannel(): string;

    /** Controls the 2D offset of the opacity map. Each component is between 0 and 1. */
    set opacityMapOffset(arg: Vec2);
    get opacityMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the opacity map. */
    set opacityMapRotation(arg: number);
    get opacityMapRotation(): number;

    /** Controls the 2D tiling of the opacity map. */
    set opacityMapTiling(arg: Vec2);
    get opacityMapTiling(): Vec2;

    /** Opacity map UV channel. */
    set opacityMapUv(arg: number);
    get opacityMapUv(): number;

    /** Use mesh vertex colors for opacity. If opacityMap is set, it'll be multiplied by vertex colors. */
    set opacityVertexColor(arg: boolean);
    get opacityVertexColor(): boolean;

    /** Vertex color channels to use for opacity. Can be "r", "g", "b" or "a". */
    set opacityVertexColorChannel(arg: string);
    get opacityVertexColorChannel(): string;

    /** Align vertices to pixel coordinates when rendering. Useful for pixel perfect 2D graphics. */
    set pixelSnap(arg: boolean);
    get pixelSnap(): boolean;

    /** Environment map intensity. */
    set reflectivity(arg: number);
    get reflectivity(): number;

    /** Defines the visibility of refraction. Material can refract the same cube map as used for reflections. */
    set refraction(arg: number);
    get refraction(): number;

    /** Defines the index of refraction, i.e. The amount of distortion. The value is calculated as (outerIor / surfaceIor), where inputs are measured indices of refraction, the one around the object and the one of its own surface. In most situations outer medium is air, so outerIor will be approximately 1. Then you only need to do (1.0 / surfaceIor). */
    set refractionIndex(arg: number);
    get refractionIndex(): number;

    /** The strength of the angular separation of colors (chromatic aberration) transmitting through a volume. Defaults to 0, which is equivalent to no dispersion. */
    set dispersion(arg: number);
    get dispersion(): number;

    /** When enabled, the material will output accumulated directional shadow value in linear space as the color. */
    set shadowCatcher(arg: boolean);
    get shadowCatcher(): boolean;

    /** The specular color of the material. This color value is 3-component (RGB), where each component is between 0 and 1. Defines surface reflection/specular color. Affects specular intensity and tint. */
    set specular(arg: Color);
    get specular(): Color;

    /** The main (primary) diffuse map of the material (default is null). */
    set specularMap(arg: Texture|null);
    get specularMap(): Texture|null;

    /** Color channels of the specular map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set specularMapChannel(arg: string);
    get specularMapChannel(): string;

    /** Controls the 2D offset of the specular map. Each component is between 0 and 1. */
    set specularMapOffset(arg: Vec2);
    get specularMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the specular map. */
    set specularMapRotation(arg: number);
    get specularMapRotation(): number;

    /** Controls the 2D tiling of the specular map. */
    set specularMapTiling(arg: Vec2);
    get specularMapTiling(): Vec2;

    /** Specular map UV channel. */
    set specularMapUv(arg: number);
    get specularMapUv(): number;

    /** Multiply specular map and/or specular vertex color by the constant specular value. */
    set specularTint(arg: boolean);
    get specularTint(): boolean;

    /** Use mesh vertex colors for specular. If specularMap or are specularTint are set, they'll be multiplied by vertex colors. */
    set specularVertexColor(arg: boolean);
    get specularVertexColor(): boolean;

    /** Vertex color channels to use for specular. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set specularVertexColorChannel(arg: string);
    get specularVertexColorChannel(): string;

    /** The factor of specular intensity, used to weight the fresnel and specularity. Default is 1.0. */
    set specularityFactor(arg: number);
    get specularityFactor(): number;

    /** (primary) diffuse map of the material (default is null). */
    set specularityFactorMap(arg: Texture|null);
    get specularityFactorMap(): Texture|null;

    /** The channel used by the specularity factor texture to sample from (default is 'a'). */
    set specularityFactorMapChannel(arg: string);
    get specularityFactorMapChannel(): string;

    /** Controls the 2D offset of the specularity factor map. Each component is between 0 and 1. */
    set specularityFactorMapOffset(arg: Vec2);
    get specularityFactorMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the specularity factor map. */
    set specularityFactorMapRotation(arg: number);
    get specularityFactorMapRotation(): number;

    /** Controls the 2D tiling of the specularity factor map. */
    set specularityFactorMapTiling(arg: Vec2);
    get specularityFactorMapTiling(): Vec2;

    /** Specularity factor map UV channel. */
    set specularityFactorMapUv(arg: number);
    get specularityFactorMapUv(): number;

    /** Toggle sheen specular effect on/off. */
    set useSheen(arg: boolean);
    get useSheen(): boolean;

    /** The specular color of the sheen (fabric) microfiber structure. This color value is 3-component (RGB), where each component is between 0 and 1. */
    set sheen(arg: Color);
    get sheen(): Color;

    /** ap The main (primary) diffuse map of the material (default is null). */
    set sheenMap(arg: Texture|null);
    get sheenMap(): Texture|null;

    /** Color channels of the sheen map to use. Can be "r", "g", "b", "a", "rgb" or any swizzled combination. */
    set sheenMapChannel(arg: string);
    get sheenMapChannel(): string;

    /** Controls the 2D offset of the sheen map. Each component is between 0 and 1. */
    set sheenMapOffset(arg: Vec2);
    get sheenMapOffset(): Vec2;

    /** Controls the 2D rotation (in degrees) of the sheen map. */
    set sheenMapRotation(arg: number);
    get sheenMapRotation(): number;

    /** Controls the 2D tiling of the sheen map. */
    set sheenMapTiling(arg: Vec2);
    get sheenMapTiling(): Vec2;

    /** Sheen map UV channel. */
    set sheenMapUv(arg: number);
    get sheenMapUv(): number;

    /** Use mesh vertex colors for sheen. If sheen map or sheen tint are set, they'll be multiplied by vertex colors. */
    set sheenVertexColor(arg: boolean);
    get sheenVertexColor(): boolean;

    
    set sheenVertexColorChannel(arg: string);
    get sheenVertexColorChannel(): string;

    /** p The main (primary) diffuse map of the material (default is null). */
    set sphereMap(arg: Texture|null);
    get sphereMap(): Texture|null;

    /** Calculate proper normals (and therefore lighting) on backfaces. */
    set twoSidedLighting(arg: boolean);
    get twoSidedLighting(): boolean;

    /** Apply fogging (as configured in scene settings) */
    set useFog(arg: boolean);
    get useFog(): boolean;

    /** Apply tonemapping (as configured in {@link Scene#rendering} or {@link CameraComponent.rendering}). Defaults to true. */
    set useTonemap(arg: boolean);
    get useTonemap(): boolean;

    /** Apply lighting */
    set useLighting(arg: boolean);
    get useLighting(): boolean;

    /** Use metalness properties instead of specular. When enabled, diffuse colors also affect specular instead of the dedicated specular map. This can be used as alternative to specular color to save space. With metalness == 0, the pixel is assumed to be dielectric, and diffuse color is used as normal. With metalness == 1, the pixel is fully metallic, and diffuse color is used as specular color instead. */
    set useMetalness(arg: boolean);
    get useMetalness(): boolean;

    /** When metalness is enabled, use the specular map to apply color tint to specular reflections. at direct angles. */
    set useMetalnessSpecularColor(arg: boolean);
    get useMetalnessSpecularColor(): boolean;

    /** Apply scene skybox as prefiltered environment map */
    set useSkybox(arg: boolean);
    get useSkybox(): boolean;


  }

  export default StandardMaterial;
`} 
/>
